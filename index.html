<!DOCTYPE html>
<html lang="hi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Operating System & Data Structures Practicals</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Copy करके paste कर लो <b>लेनदेन</b> वालो</h1>
        <!-- <div class="sub"><h2>Copy करके paste कर लो <b>लेनदेन</b> वालो</h2></div> -->
      </div>
      <div class="bar">
        <button id="copy-all">Copy All Code</button>
        <button id="download-html">Download this Webpage (.html)</button>
      </div>
    </header>

    <!-- OS PRACTICALS -->
    <h2 class="section-title">Operating System Practicals</h2>

    <!-- OS PRACTICAL 1 -->
    <section class="card" id="os-p1">
      <h2>Practical 1 — Process communication using shared memory</h2>
      <div class="aim">Aim: Understand shared memory concepts in inter-process communication</div>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">Python — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#os-code1">Copy</button></div>
        </div>
        <pre><code id="os-code1">from threading import Thread, Semaphore
import random, time

full = Semaphore(0)
empty = Semaphore(10)
mutex = Semaphore(1)

class ProducerThread(Thread):
    def __init__(self, buffer):
        Thread.__init__(self)
        self.buffer = buffer

    def run(self):
        while True:
            empty.acquire()
            mutex.acquire()
            num = random.randint(0, 5)
            self.buffer.append(num)
            print("Produced:", num)
            mutex.release()
            full.release()
            time.sleep(1)

class ConsumerThread(Thread):
    def __init__(self, buffer):
        Thread.__init__(self)
        self.buffer = buffer

    def run(self):
        while True:
            full.acquire()
            mutex.acquire()
            item = self.buffer.pop(0)
            print("Consumed:", item)
            mutex.release()
            empty.release()
            time.sleep(1)

buffer = []
ProducerThread(buffer).start()
ConsumerThread(buffer).start()</code></pre>
      </div>
    </section>

    <!-- OS PRACTICAL 2 -->
    <section class="card" id="os-p2">
      <h2>Practical 2 — Process communication using message passing</h2>
      <div class="aim">Aim: Use message queues/pipes to solve producer-consumer problem</div>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">Python — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#os-code2">Copy</button></div>
        </div>
        <pre><code id="os-code2">import threading, queue, time

def producer(q):
    for i in range(5):
        msg = f"Data {i}"
        q.put(msg)
        print("Producer sent:", msg)
        time.sleep(1)
    q.put("DONE")

def consumer(q):
    while True:
        msg = q.get()
        if msg == "DONE":
            break
        print("Consumer received:", msg)

if __name__ == "__main__":
    q = queue.Queue()
    t1 = threading.Thread(target=producer, args=(q,))
    t2 = threading.Thread(target=consumer, args=(q,))
    t1.start()
    t2.start()
    t1.join()
    t2.join()</code></pre>
      </div>
    </section>

    <!-- OS PRACTICAL 3 -->
    <section class="card" id="os-p3">
      <h2>Practical 3 — Threading and Single Thread Control Flow</h2>
      <div class="aim">Aim: Practice thread creation and lifecycle</div>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">Python — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#os-code3">Copy</button></div>
        </div>
        <pre><code id="os-code3">import threading, time

def task():
    print("Start") 
    time.sleep(2) 
    print("End")

start = time.time()

t1 = threading.Thread(target=task) 
t2 = threading.Thread(target=task)

t1.start()
t2.start()

t1.join()
t2.join()

print("Threaded Time:", round(time.time() - start, 2))

start = time.time() 
task() 
task() 
print("Sequential Time:", round(time.time() - start, 2))</code></pre>
      </div>
    </section>

    <!-- OS PRACTICAL 4 -->
    <section class="card" id="os-p4">
      <h2>Practical 4 — Multi-threading and Fibonacci Generation</h2>
      <div class="aim">Aim: Implement multi-threading to generate Fibonacci sequence</div>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">Python — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#os-code4">Copy</button></div>
        </div>
        <pre><code id="os-code4">import threading, time

fib = []
lock = threading.Lock()

def generate(n):
    a, b = 0, 1
    for _ in range(n):
        with lock:
            fib.append(a)
            a, b = b, a + b
        time.sleep(0.1)

def display(n):
    while True:
        with lock:
            print(fib)
            if len(fib) >= n:
                break
        time.sleep(0.2)

n = 10
t1 = threading.Thread(target=generate, args=(n,))
t2 = threading.Thread(target=display, args=(n,))

t1.start()
t2.start()

t1.join()
t2.join()

print("Final:", fib)</code></pre>
      </div>
    </section>

    <!-- OS PRACTICAL 5 -->
    <section class="card" id="os-p5">
      <h2>Practical 5 — Process Synchronization and Bounded Buffer Problem</h2>
      <div class="aim">Aim: Simulate producer-consumer bounded buffer using mutex and semaphore</div>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">Python — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#os-code5">Copy</button></div>
        </div>
        <pre><code id="os-code5">import threading, time, random

BUFFER_SIZE = 5
NUM_ITEMS = 5
buffer = []

empty = threading.Semaphore(BUFFER_SIZE)
full = threading.Semaphore(0)
mutex = threading.Lock()

def producer():
    for _ in range(NUM_ITEMS):
        item = random.randint(1, 100)
        empty.acquire()
        mutex.acquire()
        buffer.append(item)
        print("Produced:", item, "| Buffer:", buffer)
        mutex.release()
        full.release()
        time.sleep(random.uniform(0.5, 1.5))

def consumer():
    for _ in range(NUM_ITEMS):
        full.acquire()
        mutex.acquire()
        item = buffer.pop(0)
        print("Consumed:", item, "| Buffer:", buffer)
        mutex.release()
        empty.release()
        time.sleep(random.uniform(0.5, 1.5))

t1 = threading.Thread(target=producer)
t2 = threading.Thread(target=consumer)

t1.start()
t2.start()

t1.join()
t2.join()</code></pre>
      </div>
    </section>




    <br>   <br> <br>   <br>
    <br>   <br>
    <br>   <br> <br>   <br>
    <br>   <br>
    <br>   <br>
    <br>   <br>
    <br>   <br>
    <br>
    <br>
    <br>   <br>
    <br>   <br>
    <br>
    <br>
    <br>   <br>
    <br>   <br>
    <br>   <br>
    <br>   <br>
    <br>
    <br>
    <!-- DS PRACTICALS -->
    <h2 class="section-title">Data Structures Practicals</h2>

    <!-- DS PRACTICAL 1 -->
    <section class="card" id="ds-p1">
      <h2>Practical 1 — Insert an element at a specific position</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code1">Copy</button></div>
        </div>
        <pre><code id="ds-code1">#include .stdio.h.
int main() {
    int arr[100] = {10, 20, 30, 40, 50};
    int size = 5;
    int pos = 2;
    int val = 99;

    for (int i = size - 1; i >= pos; i--) {
        arr[i + 1] = arr[i];
    }

    arr[pos] = val;
    size++;

    printf("Array after insertion:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 2 -->
    <section class="card" id="ds-p2">
      <h2>Practical 2 — Delete an element</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code2">Copy</button></div>
        </div>
        <pre><code id="ds-code2">#include .stdio.h.
int main() {
    int arr[100] = {10, 20, 30, 40, 50};
    int size = 5;
    int pos = 2;

    for (int i = pos; i < size - 1; i++) {
        arr[i] = arr[i + 1];
    }
    size--;

    printf("Array after deletion:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 3 -->
    <section class="card" id="ds-p3">
      <h2>Practical 3 — Search for an element</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code3">Copy</button></div>
        </div>
        <pre><code id="ds-code3">#include  .stdio.h.
int main() {
    int arr[100] = {10, 20, 30, 40, 50};
    int n = 5;
    int key = 30;

    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            printf("Element %d found at index %d\n", key, i);
            return 0;
        }
    }
    printf("Element %d not found\n", key);
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 4 -->
    <section class="card" id="ds-p4">
      <h2>Practical 4 — Create a single linked list</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code4">Copy</button></div>
        </div>
        <pre><code id="ds-code4">#include .stdio.h.
#include .stdlib.h.

struct Node {
    int data;
    struct Node *next;
};

int main() {
    struct Node *head = NULL, *second = NULL, *third = NULL;

    head = (struct Node*)malloc(sizeof(struct Node));
    second = (struct Node*)malloc(sizeof(struct Node));
    third = (struct Node*)malloc(sizeof(struct Node));

    head->data = 10;
    head->next = second;

    second->data = 20;
    second->next = third;

    third->data = 30;
    third->next = NULL;

    struct Node *temp = head;
    printf("Linked list: ");
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 5 -->
    <section class="card" id="ds-p5">
      <h2>Practical 5 — Insert a node at beginning, end, and specific position</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code5">Copy</button></div>
        </div>
        <pre><code id="ds-code5">#include .stdio.h.
#include .stdlib.h.

struct Node {
    int data;
    struct Node *next;
};

int main() {
    struct Node *head = NULL, *newNode, *temp;
    int pos = 2;

    head = (struct Node*)malloc(sizeof(struct Node));
    head->data = 10;
    head->next = (struct Node*)malloc(sizeof(struct Node));
    head->next->data = 20;
    head->next->next = NULL;

    newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = 15;

    temp = head;
    for (int i = 1; i < pos - 1 && temp != NULL; i++) {
        temp = temp->next;
    }

    newNode->next = temp->next;
    temp->next = newNode;

    printf("Linked list after insertion:\n");
    temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 6 -->
    <section class="card" id="ds-p6">
      <h2>Practical 6 — Delete a node from a given position</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code6">Copy</button></div>
        </div>
        <pre><code id="ds-code6">#include .stdio.h.
#include .stdlib.h.

struct Node {
    int data;
    struct Node *next;
};

int main() {
    struct Node *head = NULL, *temp;
    head = (struct Node*)malloc(sizeof(struct Node));
    head->data = 10;
    head->next = (struct Node*)malloc(sizeof(struct Node));
    head->next->data = 20;
    head->next->next = (struct Node*)malloc(sizeof(struct Node));
    head->next->next->data = 30;
    head->next->next->next = NULL;

    printf("Original Linked List:\n");
    temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");

    // Delete first node
    temp = head;
    head = head->next;
    free(temp);

    printf("After deleting first node:\n");
    temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 7 -->
    <section class="card" id="ds-p7">
      <h2>Practical 7 — Push, Pop, and Peek operations on a Stack using arrays</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code7">Copy</button></div>
        </div>
        <pre><code id="ds-code7">#include .stdio.h.
#define SIZE 5

int stack[SIZE];
int top = -1;

int main() {
    int choice, item;

    while (1) {
        printf("\n--- Stack Menu ---\n");
        printf("1. Push\n2. Pop\n3. Peek\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        if (choice == 1) { // Push
            if (top == SIZE - 1) {
                printf("Overflow: Stack is full!\n");
            } else {
                printf("Enter item to push: ");
                scanf("%d", &item);
                top++;
                stack[top] = item;
                printf("Item %d inserted successfully\n", item);
            }
        } 
        else if (choice == 2) { // Pop
            if (top == -1) {
                printf("Underflow: Stack is empty!\n");
            } else {
                item = stack[top];
                top--;
                printf("Item %d deleted successfully\n", item);
            }
        } 
        else if (choice == 3) { // Peek
            if (top == -1) {
                printf("Stack is empty!\n");
            } else {
                printf("Top element is: %d\n", stack[top]);
            }
        } 
        else if (choice == 4) {
            break;
        } 
        else {
            printf("Invalid choice! Try again.\n");
        }
    }
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 8 -->
    <section class="card" id="ds-p8">
      <h2>Practical 8 — Enqueue, Dequeue, and Display operations on a Queue using arrays</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code8">Copy</button></div>
        </div>
        <pre><code id="ds-code8">#include .stdio.h.
#define SIZE 5

int queue[SIZE];
int front = -1, rear = -1;

int main() {
    int choice, item;

    while (1) {
        printf("\n--- Queue Menu ---\n");
        printf("1. Enqueue\n2. Dequeue\n3. Display\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        if (choice == 1) { // Enqueue
            if (rear == SIZE - 1) {
                printf("Queue is Full!\n");
            } else {
                printf("Enter value: ");
                scanf("%d", &item);
                if (front == -1)
                    front = 0;
                rear++;
                queue[rear] = item;
                printf("%d inserted\n", item);
            }
        } 
        else if (choice == 2) { // Dequeue
            if (front == -1 || front > rear) {
                printf("Queue is Empty!\n");
            } else {
                printf("%d deleted\n", queue[front]);
                front++;
            }
        } 
        else if (choice == 3) { // Display
            if (front == -1 || front > rear) {
                printf("Queue is Empty!\n");
            } else {
                printf("Queue elements: ");
                for (int i = front; i <= rear; i++) {
                    printf("%d ", queue[i]);
                }
                printf("\n");
            }
        } 
        else if (choice == 4) {
            break;
        } 
        else {
            printf("Invalid choice!\n");
        }
    }
    return 0;
}</code></pre>
      </div>
    </section>

    <!-- DS PRACTICAL 9 -->
    <section class="card" id="ds-p9">
      <h2>Practical 9 — Create a Binary Search Tree and display using inorder traversal</h2>

      <div class="codewrap">
        <div class="codebar">
          <span class="title">C — Source Code</span>
          <div class="copy"><button class="copy-btn" data-target="#ds-code9">Copy</button></div>
        </div>
        <pre><code id="ds-code9">#include .stdio.h.
#include .stdlib.h.

struct Node {
    int data;
    struct Node *left, *right;
};

struct Node* newNode(int value) {
    struct Node* temp = (struct Node*) malloc(sizeof(struct Node));
    temp->data = value;
    temp->left = temp->right = NULL;
    return temp;
}

struct Node* insert(struct Node* root, int value) {
    if (root == NULL)
        return newNode(value);
    if (value < root->data)
        root->left = insert(root->left, value);
    else if (value > root->data)
        root->right = insert(root->right, value);
    return root;
}

void inorder(struct Node* root) {
    if (root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

int main() {
    struct Node* root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);
    insert(root, 60);
    insert(root, 80);

    printf("Inorder Traversal of BST: ");
    inorder(root);
    return 0;
}</code></pre>
      </div>
    </section>

    

  </div>
  <script src="script.js" defer></script>
</body>
</html>
